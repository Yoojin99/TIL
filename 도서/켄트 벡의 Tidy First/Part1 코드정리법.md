*Tidy : 정돈하다*

# Part 1. 코드 정리법

책에서 말하는 코드 정리법은 리팩터링의 일종으로, 기존 동작을 바꾸지 않고 코드의 구조만 바꾸는 작은 움직임(move) 를 말한다.

## 01. 보호 구문

중첩문은 보기 힘들다. 따라서 가급적 `if-return` / `guard else return` 문을 사용하자.

## 02. 안 쓰는 코드

실행되지 않는 코드는 지운다. 코드는 실행될 때 가치가 생긴다. 단 항상 각 정리 과정에서는 코드를 조금만(루틴 하나/파일 하나/디렉토리 하나) 삭제해야 함.

* 코드를 지우기 걱정되는 상황
  * 실제로 사용되고 있는가? : 확실하지 않은 경우 로그를 통해 추적
  * 나중에 다시 필요하다면? : 형상 관리 도구를 통해 해결

## 03. 대칭으로 맞추기

코드는 시간이 지날수록 변화하며 시대와 사람에 따라 다르게 작성됨. 코드를 읽는 입장에서는 일관성, 패턴이 보이면 읽고 이해가 쉬움.

코드를 읽을 때 기존과 패턴이 다르다면 '다른 동작의 코드'라고 오해하기 쉬움.

## 04. 새로운 인터페이스로 기존 루틴 부르기

기존 인터페이스를 사용하기 어려운 경우(어려움/복잡함/지루함) 새로운 인터페이스를 생성해서 기존 인터페이스를 호출.

통로 인터페이스(새로 구현한 인터페이스)는 설계에서 중추적인 역할을 하며 동작 변경이 필요할 때 변경이 쉬워짐.

* 변경 후 변경이 더 쉬워지는 느낌을 받는 비슷한 경우
  * 리턴문/결과부터 정해놓고 거꾸로 코딩하기
  * TDD
  * 도우미 설계 : 특정 업무를 해주는 루틴/객체/서비스

## 05. 읽는 순서

독자의 입장에서 읽기 좋은 순으로 코드를 정렬하기. 읽는 중 다른 정리 작업을 하고 싶더라도 먼저 순서를 먼저 정리하고 이후 다른 작업을 수행. 혹은 반대 순서로 진행.

## 06. 응집도를 높이는 배치

수정해야 하는 일이 있는데 관련 코드가 여기저기 흩어진 경우 코드 순서를 바꿔 변경 요소를 가까이 배치함.

결합도를 제거할 수 있다면 결합도를 제거.

**결합도 제거 비용 + 변경 비용 < 결합하는 비용 + 변경 비용** 이어야 좋음. (결합도를 제거하는 방향)

* 결합도 제거가 어려운 상황
  * 어떻게 해야 할지 모름
  * 시간 여유 없음
  * 팀이 이미 많은 변경 작업을 하고 있는 경우 (팀이 변화를 받아들이기 위해서는 변화를 흡수할 시간이 필요함)

응집도를 높인다 ➡️ 코드를 쉽게 변경할 수 있음/코드가 명확해짐 ➡️ 결합도 제거가 가능해질 수 있음(결합도 또한 좋아짐)

## 07. 선언과 초기화를 함께 옮기기

변수 선언과 초기화는 함께 배치하여 의미파악이 쉽게 해야 한다.

데이터 종속성이 있는 경우(a 초기화 후 a 변수의 값을 b 초기화에 사용할 경우) 코드 수정 시 실수 발생 가능. 작은 단계로 작업해서 두려움을 느끼지 않는 수정에서 코드 정리 수행.

## 08. 설명하는 변수

코드 표현식들은 계속 길어지는 경우가 존재. 이럴 경우 가독성 떨어지며 다른 사람이 이해하기 어려움.

**복잡하고 큰 코드의 표현식이 있다면 일부를 추출하고 그 의도가 드러나도록 변수 이름을 지어 할당.**

이 정리법은 **힘들게 파악한 내용을 코드에 다시 넣음. 이 정리법의 장점은 표현식을 변수로 분리했기 때문에 다음에 코드를 변경할 때 둘 중 하나만 읽으면 되기 때문에 변경이 쉬움.**

e.g.

```swift
return Point(
  굉장히 긴 표현식...,
  다른 긴 매개변수
)
```

위 코드를 아래와 같이 설명하는 변수로 바꿈

```swift
x = 긴 표현식
y = 다른 긴 표현식
return Point(x, y)
```

저자는 추가로 아래의 두 가지 변경 사항은 별도의 커밋으로 분리해야 한다고 함

* 코드 정리 커밋
* 로직 변경 커밋

## 09. 설명하는 상수

코드에서 반복적으로 등장하는 상수 / 모르는 숫자가 등장하는데 이러면 상수가 무엇을 의미하는지 알아야 함.

**리터럴 상수(숫자 자체를 문자로 나타낸 표현.)를 상징적인 상수로 바꾸는 것이 좋음.**

e.g.

```swift
if response.code == 404 { ... }

// 위 코드를 아래와 같이 고칠 수 있음
let PAGE_NOT_FOUND_CODE = 404
if response.code == PAGE_NOT_FOUND_CODE { ... }

// 리터럴 상수는 코드 여러 곳에서 등장할 수 있는데 같은 의미로 사용되는 것이 맞는지 확인
// 아래와 같은 리터럴 상수는 좋지 않음
let ONE = 1
...ONE...
```

## 10. 명시적인 매개변수

Map / dictionary 등으로 매개변수를 전달할 경우 코드에서 어떤 데이터가 필요한지 알기 어려움. 또한 이무 매개변수를 수정해서 당시 코드를 작성하는 사람만 아는 암묵적인 무언가로 사용할 가능성도 있음.

e.g.

```swift
var params: [String:Any] = []
foo(params)

func foo(_ params: [String:Any]) {
  // params 에 임의로 개발자가 접근해서 데이터를 가져올 수 있으나 정확히 어떤 데이터가 필요한지 명확하지 않고 추후 다른 개발자가 쉽게 코드를 수정할 수 없음
  // params.a
  // params.b
}

// 위보다는 아래와 같이 명시적으로 매개변수를 드러내는 것이 좋음

// 책에서는 아래와 같이 나옴
func foo(_ params: [String:Any]) {
  func fooBody(a: String, b: String) {
    ...
  }
}

// 하지만 내부에 함수를 또 만들어서 매개변수를 드러내는 것에는 반대한다.
// 일단 필요한 데이터가 많을 경우 매개변수가 굉장히 많아지고 이는 가독성을 떨어뜨림
// 또한 매개변수보다는 구조체 등을 통해 명확하게 어떤 타입이 필요한 것이 드러내는 것이 가독성을 높이고 추후 수정을 쉽게 할 것이라 생각함
struct Data {
  let a: String
  let b: String
}

func foo(_ data: Data) { ... }
```

## 11. 비슷한 코드끼리

긴 코드에서 로직이 구분이 될 때는 두 부분 사이에 빈 줄을 넣어 분리함. 

매우 간단하면서 변화를 쉽게 만들 수 있음.

## 12. 도우미 추출

코드 중에서 **목적이 분명하고 나머지 코드와는 상호작용이 적은 코드 블록이 있는 경우 이를 helper 로 추출함.** Helper 의 이름은 작동 방식이 아닌 목적에 따라 지음

시간적인 결합을 표현해야 하는 경우도 있음.

```swift
foo.a()
foo.b()

// 위와 같이 연쇄적으로 호출해야 하는 경우가 있다면 아래와 같이 바꿀 수 있음
func ab() {
  foo.a()
  foo.b()
}
```

## 13. 하나의 더미

코드가 흩어져 있는 경우 코드를 전체적으로 이해하기 어려움. 필요한 만큼 흩어진 코드를 모으고 나서 정리.

**코드를 작성할 때 가장 큰 비용이 들어가는 일은 코드 작성이 아닌 읽고 이해하는데 드는 비용. 현실적으로는 한 번에 머릿속에 기억해야 할 코드의 상세 내용을 줄여줌.**

작은 코드 조각들이 서로 교류하는 방식은 코드를 더 알기 어렵게 하기 때문에 명확성을 얻기 위해서는 코드를 모아서 이해하기 어려운 부분을 추출해서 새롭게 정리해야 함.

책에서 말하는 코드를 모아야 하는 현상이 드러나는 곳

* 길고 반복되는 argument 목록 
* 반복되는 코드 (특히 조건문)
* 적절한 이름을 갖고 있지 않은 helper 함수
* 공유되어 변경에 노출된 데이터 구조

## 14. 설명하는 주석

코드에서 명확하지 않은 내용만 주석으로 작성.

코드를 읽어서 알 수 있는 부분은 작성하지 않음. 주로 코드를 왜 이렇게 작성했는지 배경을 작성하고 다른 개발자가 코드를 봤을 때 바로 알기 어려운 부분을 적음 / 미리 알았다면 좋을 내용

주석을 작성하지 않는 것보다는 작성하는게 더 나음

## 15. 불필요한 주석 지우기

코드만으로 내용을 이해할 수 있다면 주석은 삭제하기.


