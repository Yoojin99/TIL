# 3. 액션과 계산, 데이터의 차이


## 액션, 계산, 데이터

||액션|계산|데이터|
|-|-|-|-|
||실행 시점 / 횟수에 의존|입력으로 출력을 계산|이벤트에 대한 사실|
|동의어|Side-effect, Side-effecting function, impure function(순수하지 않은 함수)|Pure function, mathematical function(수학 함수)||
|예시|이메일 보내기|최댓값 찾기|이메일 메세지|

* 액션 / 계산 / 데이터를 구분하는 기술을 적용할 때
	1. 문제에 대해 생각할 때 : 문제를 액션/계산/데이터로 나눔
	2. 코딩할 때 : **액션에서 계산을 빼냄. 계산에서 데이터를 분리함. 액션➡️계산, 계산➡️데이터 전환이 가능한지 고민**
	3. 코드 읽을 때 : refactoring

## 장보기 예제

"액션에서 계산을 빼냄. 계산에서 데이터를 분리함. 액션➡️계산, 계산➡️데이터 전환이 가능한지 고민" 

**액션에서 액션/계산/데이터 를 나눌 수 있는 만큼 나누는 것이 좋음**. 다만 충분히 구현하기 쉽다고 생각되는 시점에서 더 나누는 것을 멈춰야 함.

* 계산을 가능한 한 사용하려는 이유 : 외부에 영향을 주지 않기 때문에 테스트하기 쉬움. 액션 테스트는 어려움.

1. 장보기 과정 타임라인 다이어그램

<img width="481" alt="image" src="https://github.com/Yoojin99/100-Days-of-SwiftUI-Practice/assets/41438361/b2926d1d-3740-4ff5-90b3-35d2f143b8f4">

⬆️ 모든 게 다 액션

2. 각 액션에서 계산 / 데이터 분리

<img width="676" alt="image" src="https://github.com/Yoojin99/100-Days-of-SwiftUI-Practice/assets/41438361/a45c305b-3dae-4760-a9dd-0988766e367b">

## 정리

1. 액션 / 계산 / 데이터는 어디에나 적용 가능
2. 액션 안에는 액션, 계산, 데이터 존재 가능
3. 계산은 더 작은 계산, 데이터로 나눌 수 있음
4. 데이터는 데이터만 조합 가능. **따라서 데이터를 가장 먼저 찾아야 함**
5. 계산은 종종 무의식 사고에 녹아 있기 때문에 의식적으로 생각하면 찾을 수 있음.

## 액션

**외부 세계에 영향을 주거나 받는 것. 실행 시점, 횟수에 의존**

* 시점 : 언제 실행되는지
* 횟수 : 얼마나 실행되는지 (반복)

* 구현 방법 : 함수
* 동의어
	* 순수하지 않은 함수 (Impure function)
	* 부수효과 함수 (side-effect function)
	* 부수효과가 있는 함수 (function with side effects)
* 액션 사용시 주의
	* 액션은 다루기 힘듦
	* 액션은 소프트웨어를 실행하려는 가장 중요한 이유
	1. 가능한 액션을 적게 사용
	2. 가능한 작게 만듦 (뺄 수 있는 계산, 데이터 뺌)
	3. 외부 세계와 상호작용하는 것을 제한 (액션을 호출하는 함수가 적도록..)
	4. 호출 시점에 의존하는 것을 제한

## 계산

**입력값으로 출력값을 만드는 것. 실행 시점, 횟수와 관계없이 항상 같은 입력값에 같은 출력값 리턴**

* 구현 방법 : 함수
* 액션보다 계산이 좋은 이유
	* 테스트하기 쉬움
	* 기계적인 분석(정적 분석)이 쉬움
	* 조합하기 좋음. 조합을 통해 큰 계산 만들 수 있음
* 단점
	* 실행하기 전에 어떤 일이 발생할지 모름. 코드를 보고 이해가능하지만 소프트웨어 측면에서 함수는 블랙박스.
* 동의어
	* 순수 함수 (Pure function)
	* 수학 함수 (mathmatical function)

## 데이터

**이벤트에 대한 사실. 일어난 일의 결과를 기록한 것.**

* 구현 방법 : 기본 데이터 타입
* 데이터에 의미를 담는 방법 : 데이터 구조. (e.g. 목록의 순서가 중요할 경우 순서 보장 데이터 구조 사용.) **데이터 구조로 도메인 표현 가능**
* 불변성 
	* Copy-on-write : 변경할 때 복사본 생성
	* Defensive copy : 보관하려는 데이터의 복사본 생성
* 장점
	* 데이터 자체로 할 수 있는 게 없음. 데이터 그대로 이해 가능
	1. 직렬화 : 직렬화된 데이터는 전송/저장이 쉬움. 오랫동안 사용 가능(적어도 함수보다는)
	2. 동일성 비교 : 액션/계산은 동일성 비교가 어렵
	3. 자유로운 해석 : 같은 데이터를 다양한 문제에 다르게 해석해서 사용 가능
* 단점
	* 해석이 반드시 필요. **데이터를 언제나 쉽게 해석할 수 있게 표현해야 함.**

## 구현 순서

**사용하는데 제약**

⬇️ 액션 < 계산 < 데이터 ⬆️ 

**따라서 데이터를 먼저 구현, 다음 계산, 다음 액션 순으로 구현해야 함**


## 액션의 전파

액션을 호출하는 함수는 역시 호출 시점, 횟수에 의존하게 되므로 액션.

## 정리

* 액션 : 계산으로 만든 계획 실행
* 계산 : 계획 / 결정할 때 사용
* 데이터 : 계획 / 결정의 결과
<br></br>
* 함수형 프로그래머는 액션, 계산, 데이터를 구분.
* 액션 : 실행 시점, 횟수에 의존. 외부 세계와 영향 주고받음
* 계산 : 입력값으로 출력값 만듦. 외부 세계와 영향 주고받지 X. 실행 시점, 횟수에 의존 X
* 데이터 : 이벤트에 대한 사실. 영구적으로 기록 가능
* 좋은 것 : 데이터 > 계산 > 액션
* 계산은 항상 같은 입력으로 같은 출력을 하기 때문에 테스트 쉬움


