# 2. Getting Started With async/await

## async/await 이전의 비동기

### 문제

```swift
func fetchStatus(completion: @escaping (ServerStatus) -> Void) {
  URLSession.shared.dataTask(
    with: URL(string: "http://amazingserver.com/status")!
  ) { data, response, error in
    // Decoding, error handling, etc
    completion(ServerStatus(data))
  }
.resume() }
fetchStatus { [weak viewModel] status in
  guard let viewModel else { return }
  viewModel.serverStatus = status
}
```

* 위 코드의 문제
  * `fetchStatus` 내부에서 `completion` 이 몇 번 호출될지 컴파일러가 모름. 따라서 얼마나 살아있을지랑 메모리 사용을 최적화할 수 없음.
  * 직접 메모리 관리를 해야 함. `viewModel` 을 직접 weak 하게 capture 하고 클로저가 실행되기 전에 릴리즈 되었는지를 확인해봐야 함
  * 개발자가 에러를 처리했는지 컴파일러가 모름. 개발자가 실수할 수 있음.

### 해결

최신 비동기 모델은 compiler, runtime 과 밀접하게 동작함. 위의 문제를 해결할 수 있는 세 가지 도구가 있음.

* `async` : 메서드가 비동기임을 명시함. 비동기 메서드가 결과를 리턴하기 전까지 실행을 멈출 수 있음
* `await` : `async` 로 명시된 메서드가 리턴될때까지 코드가 실행을 멈출 수 있음을 명시함
* `Task` : 비동기 작업의 단위. 완료되기를 기다리거나 완료되기 전에 취소할 수 있음

위 코드를 modern concurrency 문법으로 다시 적으면 아래와 같음

```swift
func fetchStatus() async throws -> ServerStatus {
  let (data, _) = try await URLSession.shared.data(
    from: URL(string: "http://amazingserver.com/status")!
  )
  return ServerStatus(data: data)
}
Task {
  viewModel.serverStatus = try await api.fetchStatus()
}
```

* `async` 키워드를 붙여서 함수가 실행을 중단하고 재개할 수 있음을 명시함
* 함수는 `Data` 를 리턴하거나 에러를 던지며 이는 컴파일 타임에 확인됨
* `Task` 는 클로저를 비동기 문맥에서 실행해서 컴파일러는 클로저 내에 위험한 코드를 작성하는 것을 방지할 수 있음
* `await` 키워드를 사용해서 비동기 함수를 호출할때마다 런타임에게 코드를 중지하거나 취소할 기회를 줌. 이는 시스템이 현재 task queue 내의 우선순위들을 바꿀 수 있게 해줌 (상황에 맞춰서 유연한 운용이 가능하다는 소리같음)

## 코드를 Task 들로 쪼개기

앞장에서 "코드는 각 `await` 지점마다 중지될 수 있음" 이라는 표현을 봤다.

CPU core 과 메모리같은 공유 리소스를 최적화하기 위해 Swift 는 코드를 **partial task / partial** 이라는 논리적인 단위로 분리함.

<img width="360" alt="image" src="https://github.com/user-attachments/assets/b95308aa-2c7c-406e-84f6-dd12bd1777ac">

Swift runtime 은 이 여러 **조각들을 개별적으로 비동기적으로 실행하도록 스케줄링함.** 그래서 한 partial task 가 완료되면 시스템은 코드를 그대로 다시 실행할지 아니면 다른 task 를 실행할 지 결정함.

이 때문에 `await` 가 붙은 **partial task 들이 시스템의 재량에 따라 다른 쓰레드에서 실행될 수 있음**을 기억해야 함. `await` 이후 앱의 상태에 가정을 하면 안됨. 이어지는 코드 두 줄이라도 다른 시간에 실행될 수 있음.

`async/await` 는 컴파일러에게 안전한 코드를 작성할 수 있게 해주며 runtime 은 공유 시스템 리소스를 최적화할 수 있게 해줌

## Partial Task 실행

클로저 문법과 비교하면 modern concurrency 문법은 명료함. `async`, `await`, `let` 을 써서 의도를 명시적으로 드러낼 수 있음

Concurrency model 의 근본은 비동기 코드를 **Executor** 에서 실행되는 partial task 로 쪼개는 것임

<img width="704" alt="image" src="https://github.com/user-attachments/assets/d3c42ea4-fea8-488d-b1a0-4b8389d1587d">

위 그림을 보면 

* 비동기 코드가 partial task 로 쪼개짐
* partial task 는 executor 에서 실행됨
* 각각의 partial task 들은 개별적으로 스케줄링 되기 때문에 각 partial task 사이에 다른 코드가 실행될 수 있음

## Task 생명주기 관리

Modern concurrency 의 핵심 기능 중 하나는 비동기 코드의 생명주기를 관리하는 것.

기존 멀티 쓰레드 API 의 큰 단점은 비동기 코드가 실행되면 이를 '잘' 취소하기가 어려웠음.

e.g. 원격 서버에서 컨텐츠를 불러올 때 만약 두 번 호출했다면 시스템은 의미 없는 첫 번째 요청이 사용하는 자원을 다시 가져올 수 있는 자동화된 매커니즘이 없음.

### 계층적 취소

Runtime 은 비동기 계층을 따라서 자식 task 까지 다 취소할 수 있음

<img width="300" alt="image" src="https://github.com/user-attachments/assets/23864d91-1570-4723-8dca-102f328f3429">

### escape route

Suspension point 는 escape route 를 제공해서 에러가 계층을 따라 올라갈 수 있도록 해줌. 이를 통해 코드에서 catch 하고 처리할 수 있음.

<img width="284" alt="image" src="https://github.com/user-attachments/assets/e6b01f3a-7d43-41f6-ba52-ed6d589e107a">

새로운 모델은 에러 처리 구조를 throwing function 을 사용해서 동기 메서드와 비슷하게 처리함. 또한 task 가 에러를 던지면 quick memory release 를 통해 최적화를 함.

*위의 내용들은 modern Swift concurrency model 이 안전하며 자원 사용을 최적화하며 간단한 문법을 가지고 있음에 대한 내용임*