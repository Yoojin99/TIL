# 9. 계층형 설계2

## 계층형 설계 패턴 정리

1. 직접 구현 : 함수를 읽으면서 함수 시그니처가 나타내고 있는 문제를 함수 본문에서 적절한 구체화 수준으로 해결.
2. 추상화 벽 : 인터페이스를 통해 높은 차원으로 생각. 고수준의 추상화 단계만 생각해서 두뇌 한계 극복
3. 작은 인터페이스 : 인터페이스는 작고 강력한 동작으로 구성. 최소한의 인터페이스 유지
4. 편리한 계층 : 계층을 추가하는 이유는 계층을 추가해서 작업하기 편리해야 하기 때문

## 2. 추상화 벽 (Abstraction barrier)

**세부 구현을 감춘 함수들로 이루어진 계층. 추상화 벽에 있는 함수들을 사용할 때 세부 구현을 몰라도 함수 사용 가능.**

함수형 프로그래머는 문제를 높은 수준으로 생각하기 위해 추상화 벽 사용.

**추상화 벽 : 데이터 구조를 몰라도 함수를 사용할 수 있다는 의미.**

<img width="922" alt="image" src="https://github.com/Yoojin99/100-Days-of-SwiftUI-Practice/assets/41438361/9c61f595-03e1-429f-b75d-292948dcb3eb">

### 대칭

* 마케팅 팀
	* 세부적인 구현 신경 안 써도 됨
	* 추상화 벽의 함수의 이름만 보고 동작 추론 가능.

↕️ 대칭
* 개발팀
	* 추상화 벽에 있는 함수를 사용하는 마케팅 코드 신경 안 써도 됨
	* 추상화 벽의 데이터 구조 바꿔도 마케팅 팀에 공유 안해도 됨

라이브러리, API 와 유사

### 개발팀의 데이터 구조 수정

카트 데이터 구조 수정 시 추상화 벽의 함수 모두 수정해야 함.

<img width="986" alt="image" src="https://github.com/Yoojin99/100-Days-of-SwiftUI-Practice/assets/41438361/fbe6056f-0c22-4082-9e75-987eeb583456">

* 추상화 벽 : '어떤 것을 신경 쓰지 않아도 되지?' 의 표현. 위에서는 카트 구조. 필요하지 않은 것은 무시할 수 있게 간접적인 단계를 만듦
* 추상화 벽을 넘나드는 화살표가 있다면 신경 쓰지 않아야 할 세부적인 구현을 사용하고 있다는 뜻 ➡️ 추상화 벽에 새로운 함수 생성해서 해결

## 추상화 벽을 사용할 때

모든 곳에 추상화 벽 사용하면 안됨.

1. 쉽게 구현 바꾸기 위해. 
	* **구현에 대한 확신이 없는 경우** : 추상화 벽으로 구현을 간접적으로 사용할 수 있어 구현 바꾸기 쉬움. 프로토타이핑, 최선의 구현을 확신할 수 없는 경우 유용.
	* **뭔가 바뀔 것을 알고는 있지만 준비되지 않은 경우** : e.g. 서버에서 데이터 받아야 하는데 준비되지 않은 경우
	* **만약을 대비해 코드를 만드는 것은 안됨. 쓸데 없는 코드는 줄이는 것이 좋음. 오지 않을 수 있는 미래를 위해 불필요한 코드를 작성하는 것은 안좋은 습관**
2. 코드를 읽고 쓰기 쉽게 만들기 위해 : 세부적인 걸 신경 쓰지 않아도 됨
3. 팀 간 조율해야 할 것을 줄이기 위해
4. 주어진 문제에 집중하기 위해 : 두뇌의 한계, 고민해야 할 문제는 많음. 구체적인 부분 무시해서 실수 줄이고 개발하면서 지치지 않을 수 있음

## 정리

* **추상화 벽 : 신경쓰지 않아도 되게끔 하는 것을 다루는 기술**
* **추상화 벽으로 추상화 벽 위-추상화 벽 아래 의 코드의 의존성 없앰**
	* 추상화 벽 위 코드 : 구체적인 내용 (e.g. 데이터 구조) 신경 안 써도 됨
	* 추상화 벽 아래 코드 : 높은 수준의 계층에서 함수가 어떻게 사용되는지 몰라도 됨
* 추상화 벽으로 팀 간 커뮤니케이션 비용 줄임
* 복잡한 코드 명료화

## 3. 작은 인터페이스 (minimal interface)

**새로운 코드를 추가할 위치에 관한 것. 인터페이스를 최소화해서 하위 계층에 불필요한 기능이 쓸데없이 커지는 것 방지**

**새로운 기능을 만들 때 하위 계층보다 상위 계층에 기능을 추가하고 만드는 것.** 하위 계층을 고치지 않고 상위 계층에서 문제를 해결할 수 있음.

### 마케팅 코드 추가 예시

* 시계 할인 마케팅 코드 추가 위치 고려

<img width="1017" alt="image" src="https://github.com/Yoojin99/100-Days-of-SwiftUI-Practice/assets/41438361/1e2f7502-dcb4-4bbc-b08b-a51244150b2a">

1. 추상화 벽 위
2. 추상화 벽
	* 시스템 하위 계층 코드가 증가. 좋지 않음.
	* 마케팅 함수는 구체적인 구현 신경 쓰고 싶지 않음
	* 마케팅 함수 수정할 때 개발팀에도 말해야 함. 개발팀에서 맘대로 코드 수정 불가.
	* **추상화 벽의 함수는 개발팀-마케팅팀 사이의 계약.** 계약이 늘어남. 비용이 증가.


* 제품 담을 때 로그 남기는 코드 추가 위치 고려

```swift
logAddToCart(uid, item) // db에 로그 남김. 액션
```

<img width="1004" alt="image" src="https://github.com/Yoojin99/100-Days-of-SwiftUI-Practice/assets/41438361/dc405db4-3c73-4b40-826b-49fe86c184b0">

1. 추상화 벽 위
2. 추상화 벽 안의 함수
	* `logAddToCart()` 액션 ➡️ `add_item()` 액션
	* 액션이 전체로 퍼져 테스트 어려워짐. 

**위치를 결정하는데 중요한 것은 인터페이스를 깔끔하게 유지해야 한다는 점.**

* 상황에 따라 더 좋은 위치 생길 수 있음
* 계속 좋은 위치를 찾기 위해 코드 수정해야 한다면 앱 전체를 다시 설계해야 함.
* 인터페이스를 최소화해서 생기는 불필요한 변경/확장을 방지

## 정리

**완전한 추상화 벽-최소한의 인터페이스 사이에 유연하게 조절**

* 추상화 벽에 코드 많을수록
	* 구현 바뀌었을 때 고칠거 많음
	* 팀 간 조율해야 할 거 많음
	* 알아야 할 게 많아 사용 어려움
* 추상화 벽의 코드는 낮은 수준이기 때문에 더 많은 버그 있을 수 있음
* 낮은 수준의 코드는 이해하기 어려움
* 상위 계층에 함수 생성할 때 현 계층의 함수로 구현하기
* 이상적인 계층은 필요한 함수만을 가지고 있는 것. 완전하고, 적고, 시간에 따라 바뀌지 말아야 함. 현실적으로 이 목표에 가는 것이 중요.

## 4. 편리한 계층 (comfortable layer)

**언제 패턴을 적용하고 언제 멈춰야 하는지 실용적인 방법을 알려줌. 작업하는 코드 편리하면 설계를 멈춰도 됨. 구체적인 것 많이 알거나 코드 지저분하면 패턴 적용**

* 시간이 지나면서 추상화 벽의 쓸모가 달라질 수 있음
* 거대한 추상 계층 만들 시간은 적고 비즈니스는 기다려주지 않음
* 어떤 코드도 이상적인 모습에 도달 못함
* **개발자로서의 필요성, 비즈니스 요구사항 모두를 만족시켜야 함**

## 호출 그래프의 구조에 있는 코드의 정보

호출 그래프에서 함수 이름 없애면 구조에 대한 추상적인 모습 볼 수 있음. **호출 그래프에서 함수 이름 빼고 봤을 때 비기능적 요구사항에 대한 답 파악 가능**

* 기능적 요구사항 (functional requirements) : 소프트웨어가 정확히 해야 하는 일
* 비기능적 요구사항 (nonfunctional requirements)
	* 유지보수성 (maintainability) : 요구사항이 바뀔 때 가장 쉽게 고칠 수 있는 코드는?
	* 테스트성 (testability) : 테스트해야 하는 가장 중요한 코드는?
	* 재사용성 (reusability) : 재사용하기 좋은 코드는?

### 유지보수성

**그래프 가장 위의 코드가 가장 고치기 쉬움.** 아래의 코드를 수정하면 아래의 코드를 기반으로 수많은 코드가 작성되었기 때문에 수정 어려움. **높은 곳은 적게 유지하는 것이 좋음.**

* 자주 바뀌는 코드는 위에 두기 e.g. 비즈니스 로직
* 자주 바뀌면 안 되는 코드는 아래 두기

### 테스트성

**아래에 있는 코드일수록 테스트가 중요함. 하위 계층을 테스트할수록 얻은 게 오래감** 

모든 코드 테스트는 현실적으로 불가. 테스트 작성도 시간이기 때문에 효율적으로 해야 함

* 위의 코드를 테스트
	* 상위 계층 함수에서 호출하는 하위 계층 함수들이 같이 잘 동작하는지 확인 가능. 그래도 확신 못함. 에러 + 에러 조합으로 성공했다면?
	* 상위 계층 함수는 테스트 어려움
	* **상위에 있을수록 자주 바뀌기 때문에 테스트도 오래 못 감**
* 아래의 코드를 테스트
	* 많은 코드가 가장 아래의 잘 동작하는 코드에 의존
	* 적게 바뀌고 테스트 하기 쉬움

### 재사용성

**아래로 가리키는 함수 적을수록 재사용 좋음. 아래로 가리키는 화살표 많을수록 (outdegree) 재사용 어려움** 

재사용하면 코드 다시 만들 필요 없어 고치거나 테스트 필요 없음. 시간, 비용 줄임. **낮은 계층으로 함수를 추출하면 재사용 가능성 높아짐**

## 결론

* 계층형 설계 : 바로 아래 계층의 함수를 사용해 현 계층의 함수를 구현하는 기술
* 추상화 벽 패턴 : 세부적인 내용 감춰 더 높은 차원에서 생각 가능
* 작은 인터페이스 패턴 : 완성된 인터페이스에 가깝게 계층 구성 가능. 
* 편리한 계층 패턴 : 다른 패턴을 요구사항에 맞게 구현. 
* 호출 그래프 구조 : 비기능적 규칙 파악 가능
